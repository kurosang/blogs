# 不同模块的标准与区别（CommonJS和ES6 Module）

## 1. CommonJS
```
    // calculator.js
    var name = 'calculator.js'

    // index.js
    var name = 'index.js'
    require('./calculator.js')
    console.log(name)  // index.js
```
## 导出
导出是一个模块向外暴露自身的唯一方式。
```
module.exports = {
    name: 'calculator',
    add: function(a, b) {
        return a + b
    }
}
```
CommonJS模块内部会有一个module对象用于存放当前模块的信息，可以理解成在每个模块的最开始定义了以下对象：
```
var module = {...}
// 模块自身逻辑
module.exports = {...}
```
module.exports 用来指定该模块要对外暴露哪些内容，在上面的代码中我们导出了一个对象，包含name和add两个属性。为了书写方便，CommonJS也支持另一种简化的导出方式————直接使用exports。
```
exports.name = 'calculator'
exports.add = function(a, b) {
    return a + b
}
```
在实现效果上，这段代码和上面的module.exports没有任何不同。其内在机制是将exports指向了module.exports，而module.exports在初始化时是一个空对象。我们可以简单地理解为，CommonJS在每个模块的首部默认添加了以下代码：
```
var module = {
    exports: {}
}
var exports = module.exports
```
因此，为exports.add赋值相当于在module.exports对象上添加了一个属性。

在使用exports时要注意一个问题，即不要直接给exports赋值，否则会导致其失效。如：
```
exports = {
    name: 'calculator'
}
```
上面代码中，由于对exports进行了赋值操作，使其指向了新的对象，module.exports却仍然是原来的空对象，因此name属性并不会被导出。

另一个在导出时容易犯的错误是不恰当地把module.exports与exports混用。
```
exports.add = function(a, b) {
    return a + b
}
module.exports = {
    name: 'calculator'
}
```
上面代码先通过exports导出了add属性，然后将module.exports重新赋值为另外一个对象。这会导致原本拥有add属性的对象丢失了，最后导出的只有name。

另外，要注意导出语句不代表末尾，导出语句后面的代码照常执行。

## 导入
注意require模块只会加载一次。

require函数可以接收表达式，因此可以动态的加载模块。
****
## 2. ES6 Module
```
// calc.js
export default {
    name: 'calc',
    add: function(a, b) {
        return a + b
    }
}

//index.js
import calc from './calc.js'
const sum = calc.add(2, 3)
console.log(sum) // 5
```
## 导出
* 命名导出

    1）
    ```
    export const name = 'calc'
    ```

    2）
    ```
    const name = 'calc'
    export { name }
    ```
* 默认导出
    ```
    export defalut {
        name: 'calc',
        ...
    }
    ```
## 导入
```
import { name } from './calc.js'
// 或者
import calc from './calc.js'
```
****
## 3. CommonJS和ES6 Module两者区别
* 前者建立模块依赖关系是在运行时，后者是在编译时。
* 在模块导入方面，前者导入的是值拷贝，后者导入的是只读的变量映射。
* 后者通过其静态特性可以进行编译过程中的优化，并且具备处理循环依赖的能力。